# -*- coding: utf-8; mode: tcl; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- vim:fenc=utf-8:ft=tcl:et:sw=4:ts=4:sts=4

PortSystem          1.0
PortGroup           muniversal 1.0
PortGroup           github 1.0

github.setup        libffi libffi 3.4.2 v
revision            1
github.tarball_from releases
categories          devel
platforms           darwin
license             MIT
maintainers         nomaintainer

description         A portable foreign function interface library
long_description    The libffi library provides a portable, high level \
                    programming interface to various calling \
                    conventions. This allows a programmer to call any \
                    function specified by a call interface description \
                    at run-time.

homepage            https://www.sourceware.org/libffi/

checksums           rmd160 05606691305f980b3ea8a15aeed333780cc0c844 \
                    sha256 540fb721619a6aba3bdeef7d940d8e9e0e6d2c193595bc243241b77ff9e93620 \
                    size   1351355

patchfiles          powerpc-g3.patch

if {${os.platform} eq "darwin" && ${os.major} < 10 && ![string match *clang* ${configure.compiler}]} {
    # https://trac.macports.org/ticket/61170
    patchfiles-append   patch-libffi-intel-leopard-sysv.diff \
                        patch-libffi-tests-gcc42.diff
}

# Don't use macports gcc or clang toolchains to build this due to dependency cycles
compiler.blacklist-append macports-*

if {${os.platform} eq "darwin" && ${os.major} < 11} {
    # Doesn't actually use C++, and having the stdlib set to libc++
    # on 10.6 causes a macports-clang compiler to be chosen.
    configure.cxx_stdlib
}

# Older versions of cctools have a history of being problematic with complex
# asm like libffi has, so opt for the integrated assembler if it's available
if {[string match *clang* ${configure.compiler}]} {
    configure.cflags-append -integrated-as
}

array set merger_host {
    ppc64 powerpc-apple-darwin
}

lappend merger_dont_diff \
    ${prefix}/include/ffi.h \
    ${prefix}/include/ffitarget.h

proc symlink_prev_dylib {} {
    global destroot prefix

    # Patterns for the dylib file, both glob and regex
    set libffi_dylib_glob \
        libffi\.\[0-9\]*\.dylib
    set libffi_dylib_regex \
        libffi\.\(\[0-9\]+\)\.dylib

    # Grab the full path to the new dylib
    set dylib_list \
        [glob -type f ${destroot}${prefix}/lib/${libffi_dylib_glob}]
    ui_debug "dylib_list: ${dylib_list}"
    set dylib_count \
        [llength ${dylib_list}]

    # Ensure there is one, and only one
    if {${dylib_count} != 1} {
        ui_error "Dylib count mismatch; should be 1, but is: ${dylib_count}"
        return -code error "Dylib count mismatch"
    }

    # Grab dylib path from the list, and extract the name alone
    set dylib_path \
        [lindex ${dylib_list} 0]
    set dylib_file \
        [file tail ${dylib_path}]
    ui_debug "dylib_file: ${dylib_file}"

    # Extract dylib version number
    set dylib_ver_list \
        [regexp -inline ${libffi_dylib_regex} ${dylib_file}]
    set dylib_ver \
        [lindex ${dylib_ver_list} 1]
    ui_debug "dylib_ver: ${dylib_ver}"

    # Generate symlink name, based on previous version (one prior)
    set dylib_ver_prev \
        [expr {${dylib_ver} - 1}]
    ui_debug "dylib_ver_prev: ${dylib_ver_prev}"
    set dylib_link_prev \
        libffi.${dylib_ver_prev}.dylib
    ui_debug "dylib_link_prev: ${dylib_link_prev}"

    # And finally, create the symlink
    ln -s \
        ${prefix}/lib/${dylib_file} \
        ${destroot}${prefix}/lib/${dylib_link_prev}
}

post-destroot {
    symlink_prev_dylib
}

depends_test-append port:expect port:dejagnu
test.run            yes
test.target         check

github.livecheck.regex {(\d+(?:\.\d+)+)}
